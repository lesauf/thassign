{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/CSEG/Desktop/thassign/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BehaviorSubject } from 'rxjs';\nimport { CommonService } from '@src/app/core/services/common.service';\nimport { ProgramConverter } from '@src/app/core/models/program.converter';\nimport { Program } from '@src/app/core/models/program.model';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@src/app/modules/assignments/services/assignment.service\";\nimport * as i2 from \"@src/app/core/services/backend.service\";\nimport * as i3 from \"@src/app/core/services/epub.service\";\nimport * as i4 from \"@src/app/core/services/message.service\";\nimport * as i5 from \"@src/app/core/services/part.service\";\nimport * as i6 from \"@ngx-translate/core\";\nimport * as i7 from \"@src/app/modules/users/user.service\";\n/**\r\n * - Parse epub to extract all the assignments\r\n */\nexport class ProgramService extends CommonService {\n  constructor(assignmentService, backendService, epubService, messageService, partService, translateService, userService) {\n    super();\n    this.assignmentService = assignmentService;\n    this.backendService = backendService;\n    this.epubService = epubService;\n    this.messageService = messageService;\n    this.partService = partService;\n    this.translateService = translateService;\n    this.userService = userService;\n    /**\r\n     * Map of lang -> shortLangCode\r\n     */\n    this.langs = {\n      en: 'E',\n      fr: 'F'\n    };\n    /**\r\n     * Current month program store\r\n     */\n    this.mProgramStore = new BehaviorSubject(null);\n    /**\r\n     * Current month program observable\r\n     */\n    this.mPrograms = this.mProgramStore.asObservable();\n    /**\r\n     * A map of all the assignments\r\n     * Assignment.key => Assignment\r\n     */\n    this.allAssignments = new Map();\n  }\n  /**\r\n   * Create Program instances from JSON or map of JSON objects\r\n   *\r\n   * @param roughPrograms JSON object/array with properties\r\n   */\n  createProgram(roughPrograms, allParts, allUsers) {\n    // const allParts = this.partService.getParts();\n    if (roughPrograms instanceof Array) {\n      return roughPrograms.map(obj => new Program(this.convertAssignments(obj), allParts, allUsers));\n    } else {\n      return new Program(this.convertAssignments(roughPrograms), allParts, allUsers);\n    }\n  }\n  /**\r\n   * Get programs from store\r\n   */\n  getPrograms() {\n    return this.dataStore.getValue();\n  }\n  /**\r\n   * get program of the current month from the store\r\n   *\r\n   * @returns\r\n   */\n  getProgramsByMonth(meeting, month) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const monthStr = month.toFormat('yyyyMM'); // 202011\n      let storedPrograms = _this.dataStore.getValue();\n      if (storedPrograms !== null) {\n        // Not the initial emission\n        let mPrograms = new Map();\n        if (storedPrograms.length !== 0) {\n          // If there are programs in the db filter the ones for\n          // this meeting and month\n          let fPrograms = storedPrograms.filter(program => {\n            const sameMeeting = program.meeting === meeting;\n            const sameMonth = program.month.toString() === month.toString();\n            // Remove the programs whose week are not in this month\n            return sameMeeting && sameMonth;\n          });\n          mPrograms = _this.convertProgramsToMap(fPrograms);\n        }\n        // If programs for this month, get the reference\n        if (mPrograms.size === 0) {\n          console.log('From Reference');\n          mPrograms = yield _this.getReferencePrograms(meeting, month);\n        } else {\n          console.log('From DB');\n        }\n        // Emit the program/reference for this month\n        _this.mProgramStore.next(mPrograms);\n      }\n    })();\n  }\n  /**\r\n   * Get all programs from server\r\n   */\n  storePrograms(programs, allParts, allUsers) {\n    try {\n      // convert to Program objects\n      const allPrograms = this.createProgram(programs, allParts, allUsers);\n      // Update Assignment store\n      this.assignmentService.storeAssignments(this.extractAllAssignments(allPrograms));\n      // const allPrograms = programs;\n      // console.log('Programs to put in the store :', allPrograms);\n      this.updateStore(allPrograms);\n      return allPrograms;\n    } catch (error) {\n      this.handleError('storePrograms', error, [], '');\n    }\n  }\n  /**\r\n   * Get the english programs list (the reference) either from the DB\r\n   * or the epub file\r\n   * @param meeting\r\n   * @param month\r\n   */\n  getReferencePrograms(meeting, month) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.mwbLangCode = _this2.langs[_this2.translateService.currentLang];\n      let programs = [];\n      if (meeting === 'midweek') {\n        // get the midweek meeting from the db ()\n        // const dbResults = await this.backendService\n        //   .getCollectionWithConverter('referencePrograms', new ProgramConverter())\n        //   .where('month', '==', month.toFormat('yyyyMM'))\n        //   .get();\n        // if (!dbResults.empty) {\n        //   // if (dbResults.exists) {\n        //   dbResults.forEach(function (doc) {\n        //     programs[doc.id] = doc.data();\n        //   });\n        // } else {\n        // If not in the db get it from the epub and\n        // if not found in the epub throw error\n        const epubFilename = `mwb_${_this2.mwbLangCode}_${month.toFormat('yyyyMM')}`;\n        programs = yield _this2.getProgramFromEpub(epubFilename);\n        // Save reference programs in the DB ?\n        // await this.backendService.upsertManyDocs(\n        //   'referencePrograms',\n        //   Object.values(programs),\n        //   'set',\n        //   false,\n        //   new ProgramConverter()\n        // );\n        // }\n      } else if (meeting === 'weekend') {\n        // Weekend meeting preparation goes here\n      } else {\n        _this2.messageService.add(meeting + ': There is not such meeting for now');\n      }\n      // Optionally convert the programs here to a map\n      return _this2.convertProgramsToMap(programs);\n    })();\n  }\n  /**\r\n   * For now I can only safely extract program from english epub\r\n   * @todo Modify to extract from any language epub\r\n   * @param epubFilename\r\n   * @param week\r\n   */\n  getProgramFromEpub(epubFilename, week) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const signedInUserId = _this3.backendService.getSignedInUser()._id;\n      const roughPrograms = yield _this3.epubService.getProgramsFromEpub(epubFilename, signedInUserId);\n      return _this3.createProgram(roughPrograms, _this3.partService.getParts(), _this3.userService.getUsers());\n    })();\n  }\n  convertAssignments(roughProgram) {\n    // Try to get the corresponding parts of the assignments\n    roughProgram['assignments'].forEach((ass, index) => {\n      // This is when we build the program from the reference\n      roughProgram['assignments'][index].part = this.partService.getPartByTranslatedTitle(ass.title, ass.partSection, ass.description);\n    });\n    return roughProgram;\n  }\n  convertProgramsToMap(programs) {\n    const convPrograms = new Map();\n    if (programs !== null) {\n      programs.forEach(program => {\n        convPrograms.set(program._id, program);\n      });\n    }\n    return convPrograms;\n  }\n  /**\r\n   * Update the allAssignments property\r\n   * It converts all the assignments in the programs\r\n   * to a map\r\n   */\n  extractAllAssignments(allPrograms) {\n    let a = [];\n    allPrograms.forEach(p => {\n      // First convert all the assignments to a 2D array\n      // of [ass.key, ass]\n      const ass2d = p.assignments.map(ass => [ass.key, ass]);\n      a = a.concat(ass2d);\n    });\n    return new Map(a);\n  }\n  //////// Save methods //////////\n  /**\r\n   * Insert program if not existent, update it otherwise\r\n   * @param program\r\n   */\n  savePrograms(programs) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        // throw 'errr';\n        yield _this4.backendService.upsertManyDocs('programs', programs, 'set', false, new ProgramConverter());\n        _this4.messageService.presentToast('program-save-success');\n      } catch (error) {\n        // this.messageService.presentToast('program-save-success');\n        _this4.handleError('saveProgram', error);\n      }\n    })();\n  }\n  static #_ = this.ɵfac = function ProgramService_Factory(t) {\n    return new (t || ProgramService)(i0.ɵɵinject(i1.AssignmentService), i0.ɵɵinject(i2.BackendService), i0.ɵɵinject(i3.EpubService), i0.ɵɵinject(i4.MessageService), i0.ɵɵinject(i5.PartService), i0.ɵɵinject(i6.TranslateService), i0.ɵɵinject(i7.UserService));\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: ProgramService,\n    factory: ProgramService.ɵfac,\n    providedIn: 'root'\n  });\n}","map":{"version":3,"names":["BehaviorSubject","CommonService","ProgramConverter","Program","ProgramService","constructor","assignmentService","backendService","epubService","messageService","partService","translateService","userService","langs","en","fr","mProgramStore","mPrograms","asObservable","allAssignments","Map","createProgram","roughPrograms","allParts","allUsers","Array","map","obj","convertAssignments","getPrograms","dataStore","getValue","getProgramsByMonth","meeting","month","_this","_asyncToGenerator","monthStr","toFormat","storedPrograms","length","fPrograms","filter","program","sameMeeting","sameMonth","toString","convertProgramsToMap","size","console","log","getReferencePrograms","next","storePrograms","programs","allPrograms","storeAssignments","extractAllAssignments","updateStore","error","handleError","_this2","mwbLangCode","currentLang","epubFilename","getProgramFromEpub","add","week","_this3","signedInUserId","getSignedInUser","_id","getProgramsFromEpub","getParts","getUsers","roughProgram","forEach","ass","index","part","getPartByTranslatedTitle","title","partSection","description","convPrograms","set","a","p","ass2d","assignments","key","concat","savePrograms","_this4","upsertManyDocs","presentToast","_","i0","ɵɵinject","i1","AssignmentService","i2","BackendService","i3","EpubService","i4","MessageService","i5","PartService","i6","TranslateService","i7","UserService","_2","factory","ɵfac","providedIn"],"sources":["C:\\Users\\CSEG\\Desktop\\thassign\\src\\app\\core\\services\\program.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { DateTime } from 'luxon';\r\nimport { BehaviorSubject, interval, Observable, of } from 'rxjs';\r\nimport { TranslateService } from '@ngx-translate/core';\r\n\r\nimport { AssignmentService } from '@src/app/modules/assignments/services/assignment.service';\r\nimport { BackendService } from '@src/app/core/services/backend.service';\r\nimport { CommonService } from '@src/app/core/services/common.service';\r\nimport { EpubService } from '@src/app/core/services/epub.service';\r\nimport { MessageService } from '@src/app/core/services/message.service';\r\nimport { PartService } from '@src/app/core/services/part.service';\r\nimport { UserService } from '@src/app/modules/users/user.service';\r\nimport { meetingName } from '@src/app/core/types/meeting.type';\r\nimport { ProgramConverter } from '@src/app/core/models/program.converter';\r\nimport { Assignment } from '@src/app/core/models/assignment/assignment.model';\r\nimport { Part } from '@src/app/core/models/part/part.model';\r\nimport { Program } from '@src/app/core/models/program.model';\r\nimport { User } from '@src/app/core/models/user/user.model';\r\n/**\r\n * - Parse epub to extract all the assignments\r\n */\r\n@Injectable({\r\n  providedIn: 'root',\r\n})\r\nexport class ProgramService extends CommonService<Program> {\r\n  /**\r\n   * Reference programs\r\n   * Map of week to programs\r\n   */\r\n  referencePrograms: Map<string, Program[]>;\r\n\r\n  /**\r\n   * Map of lang -> shortLangCode\r\n   */\r\n  langs = { en: 'E', fr: 'F' };\r\n\r\n  /**\r\n   * Current month program store\r\n   */\r\n  private mProgramStore: BehaviorSubject<\r\n    Map<string, Program>\r\n  > = new BehaviorSubject(null);\r\n\r\n  /**\r\n   * Current month program observable\r\n   */\r\n  mPrograms: Observable<\r\n    Map<string, Program>\r\n  > = this.mProgramStore.asObservable();\r\n\r\n  mwbLangCode: string;\r\n\r\n  /**\r\n   * A map of all the assignments\r\n   * Assignment.key => Assignment\r\n   */\r\n  allAssignments: Map<string, Assignment> = new Map();\r\n\r\n  constructor(\r\n    protected assignmentService: AssignmentService,\r\n    protected backendService: BackendService,\r\n    protected epubService: EpubService,\r\n    protected messageService: MessageService,\r\n    protected partService: PartService,\r\n    protected translateService: TranslateService,\r\n    protected userService: UserService\r\n  ) {\r\n    super();\r\n  }\r\n\r\n  /**\r\n   * Create Program instances from JSON or map of JSON objects\r\n   *\r\n   * @param roughPrograms JSON object/array with properties\r\n   */\r\n  createProgram(\r\n    roughPrograms: object,\r\n    allParts?: Part[],\r\n    allUsers?: User[]\r\n  ): Program | Program[] {\r\n    // const allParts = this.partService.getParts();\r\n    if (roughPrograms instanceof Array) {\r\n      return roughPrograms.map(\r\n        (obj) => new Program(this.convertAssignments(obj), allParts, allUsers)\r\n      ) as Program[];\r\n    } else {\r\n      return new Program(\r\n        this.convertAssignments(roughPrograms),\r\n        allParts,\r\n        allUsers\r\n      ) as Program;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get programs from store\r\n   */\r\n  getPrograms(): Program[] {\r\n    return this.dataStore.getValue() as Program[];\r\n  }\r\n\r\n  /**\r\n   * get program of the current month from the store\r\n   *\r\n   * @returns\r\n   */\r\n  async getProgramsByMonth(meeting: meetingName, month: DateTime) {\r\n    const monthStr = month.toFormat('yyyyMM'); // 202011\r\n\r\n    let storedPrograms = this.dataStore.getValue();\r\n\r\n    if (storedPrograms !== null) {\r\n      // Not the initial emission\r\n      let mPrograms: Map<any, any> = new Map();\r\n\r\n      if (storedPrograms.length !== 0) {\r\n        // If there are programs in the db filter the ones for\r\n        // this meeting and month\r\n        let fPrograms = storedPrograms.filter((program) => {\r\n          const sameMeeting = program.meeting === meeting;\r\n          const sameMonth = program.month.toString() === month.toString();\r\n\r\n          // Remove the programs whose week are not in this month\r\n          return sameMeeting && sameMonth;\r\n        });\r\n\r\n        mPrograms = this.convertProgramsToMap(fPrograms) as Map<\r\n          string,\r\n          Program\r\n        >;\r\n      }\r\n\r\n      // If programs for this month, get the reference\r\n      if (mPrograms.size === 0) {\r\n        console.log('From Reference');\r\n        mPrograms = await this.getReferencePrograms(meeting, month);\r\n      } else {\r\n        console.log('From DB');\r\n      }\r\n\r\n      // Emit the program/reference for this month\r\n      this.mProgramStore.next(mPrograms);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all programs from server\r\n   */\r\n  storePrograms(\r\n    programs: any[],\r\n    allParts?: Part[],\r\n    allUsers?: User[]\r\n  ): Program[] {\r\n    try {\r\n      // convert to Program objects\r\n      const allPrograms = this.createProgram(\r\n        programs,\r\n        allParts,\r\n        allUsers\r\n      ) as Program[];\r\n      // Update Assignment store\r\n      this.assignmentService.storeAssignments(\r\n        this.extractAllAssignments(allPrograms)\r\n      );\r\n\r\n      // const allPrograms = programs;\r\n      // console.log('Programs to put in the store :', allPrograms);\r\n      this.updateStore(allPrograms);\r\n\r\n      return allPrograms;\r\n    } catch (error) {\r\n      this.handleError('storePrograms', error, [], '');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the english programs list (the reference) either from the DB\r\n   * or the epub file\r\n   * @param meeting\r\n   * @param month\r\n   */\r\n  async getReferencePrograms(meeting: meetingName, month: DateTime) {\r\n    this.mwbLangCode = this.langs[this.translateService.currentLang];\r\n\r\n    let programs = [];\r\n\r\n    if (meeting === 'midweek') {\r\n      // get the midweek meeting from the db ()\r\n      // const dbResults = await this.backendService\r\n      //   .getCollectionWithConverter('referencePrograms', new ProgramConverter())\r\n      //   .where('month', '==', month.toFormat('yyyyMM'))\r\n      //   .get();\r\n\r\n      // if (!dbResults.empty) {\r\n      //   // if (dbResults.exists) {\r\n      //   dbResults.forEach(function (doc) {\r\n      //     programs[doc.id] = doc.data();\r\n      //   });\r\n      // } else {\r\n      // If not in the db get it from the epub and\r\n      // if not found in the epub throw error\r\n      const epubFilename = `mwb_${this.mwbLangCode}_${month.toFormat(\r\n        'yyyyMM'\r\n      )}`;\r\n      programs = await this.getProgramFromEpub(epubFilename);\r\n\r\n      // Save reference programs in the DB ?\r\n      // await this.backendService.upsertManyDocs(\r\n      //   'referencePrograms',\r\n      //   Object.values(programs),\r\n      //   'set',\r\n      //   false,\r\n      //   new ProgramConverter()\r\n      // );\r\n      // }\r\n    } else if (meeting === 'weekend') {\r\n      // Weekend meeting preparation goes here\r\n    } else {\r\n      this.messageService.add(meeting + ': There is not such meeting for now');\r\n    }\r\n\r\n    // Optionally convert the programs here to a map\r\n    return this.convertProgramsToMap(programs);\r\n  }\r\n\r\n  /**\r\n   * For now I can only safely extract program from english epub\r\n   * @todo Modify to extract from any language epub\r\n   * @param epubFilename\r\n   * @param week\r\n   */\r\n  async getProgramFromEpub(epubFilename: string, week?: DateTime) {\r\n    const signedInUserId = this.backendService.getSignedInUser()._id;\r\n    const roughPrograms = await this.epubService.getProgramsFromEpub(\r\n      epubFilename,\r\n      signedInUserId\r\n    );\r\n\r\n    return this.createProgram(\r\n      roughPrograms,\r\n      this.partService.getParts(),\r\n      this.userService.getUsers()\r\n    ) as Program[];\r\n  }\r\n\r\n  convertAssignments<T>(roughProgram: T): T {\r\n    // Try to get the corresponding parts of the assignments\r\n    roughProgram['assignments'].forEach((ass, index) => {\r\n      // This is when we build the program from the reference\r\n      roughProgram['assignments'][\r\n        index\r\n      ].part = this.partService.getPartByTranslatedTitle(\r\n        ass.title,\r\n        ass.partSection,\r\n        ass.description\r\n      );\r\n    });\r\n\r\n    return roughProgram;\r\n  }\r\n\r\n  convertProgramsToMap(programs: any) {\r\n    const convPrograms = new Map();\r\n\r\n    if (programs !== null) {\r\n      programs.forEach((program) => {\r\n        convPrograms.set(program._id, program);\r\n      });\r\n    }\r\n\r\n    return convPrograms;\r\n  }\r\n\r\n  /**\r\n   * Update the allAssignments property\r\n   * It converts all the assignments in the programs\r\n   * to a map\r\n   */\r\n  extractAllAssignments(allPrograms: Program[]): Map<string, Assignment> {\r\n    let a = [];\r\n    allPrograms.forEach((p) => {\r\n      // First convert all the assignments to a 2D array\r\n      // of [ass.key, ass]\r\n      const ass2d = p.assignments.map((ass) => [ass.key, ass]);\r\n\r\n      a = a.concat(ass2d);\r\n    });\r\n\r\n    return new Map(a);\r\n  }\r\n\r\n  //////// Save methods //////////\r\n  /**\r\n   * Insert program if not existent, update it otherwise\r\n   * @param program\r\n   */\r\n  async savePrograms(programs: Program[]): Promise<void> {\r\n    try {\r\n      // throw 'errr';\r\n      await this.backendService.upsertManyDocs(\r\n        'programs',\r\n        programs,\r\n        'set',\r\n        false,\r\n        new ProgramConverter()\r\n      );\r\n\r\n      this.messageService.presentToast('program-save-success');\r\n    } catch (error) {\r\n      // this.messageService.presentToast('program-save-success');\r\n      this.handleError<any>('saveProgram', error);\r\n    }\r\n  }\r\n}\r\n"],"mappings":";AAEA,SAASA,eAAe,QAAkC,MAAM;AAKhE,SAASC,aAAa,QAAQ,uCAAuC;AAMrE,SAASC,gBAAgB,QAAQ,wCAAwC;AAGzE,SAASC,OAAO,QAAQ,oCAAoC;;;;;;;;;AAE5D;;;AAMA,OAAM,MAAOC,cAAe,SAAQH,aAAsB;EAkCxDI,YACYC,iBAAoC,EACpCC,cAA8B,EAC9BC,WAAwB,EACxBC,cAA8B,EAC9BC,WAAwB,EACxBC,gBAAkC,EAClCC,WAAwB;IAElC,KAAK,EAAE;IARG,KAAAN,iBAAiB,GAAjBA,iBAAiB;IACjB,KAAAC,cAAc,GAAdA,cAAc;IACd,KAAAC,WAAW,GAAXA,WAAW;IACX,KAAAC,cAAc,GAAdA,cAAc;IACd,KAAAC,WAAW,GAAXA,WAAW;IACX,KAAAC,gBAAgB,GAAhBA,gBAAgB;IAChB,KAAAC,WAAW,GAAXA,WAAW;IAlCvB;;;IAGA,KAAAC,KAAK,GAAG;MAAEC,EAAE,EAAE,GAAG;MAAEC,EAAE,EAAE;IAAG,CAAE;IAE5B;;;IAGQ,KAAAC,aAAa,GAEjB,IAAIhB,eAAe,CAAC,IAAI,CAAC;IAE7B;;;IAGA,KAAAiB,SAAS,GAEL,IAAI,CAACD,aAAa,CAACE,YAAY,EAAE;IAIrC;;;;IAIA,KAAAC,cAAc,GAA4B,IAAIC,GAAG,EAAE;EAYnD;EAEA;;;;;EAKAC,aAAaA,CACXC,aAAqB,EACrBC,QAAiB,EACjBC,QAAiB;IAEjB;IACA,IAAIF,aAAa,YAAYG,KAAK,EAAE;MAClC,OAAOH,aAAa,CAACI,GAAG,CACrBC,GAAG,IAAK,IAAIxB,OAAO,CAAC,IAAI,CAACyB,kBAAkB,CAACD,GAAG,CAAC,EAAEJ,QAAQ,EAAEC,QAAQ,CAAC,CAC1D;KACf,MAAM;MACL,OAAO,IAAIrB,OAAO,CAChB,IAAI,CAACyB,kBAAkB,CAACN,aAAa,CAAC,EACtCC,QAAQ,EACRC,QAAQ,CACE;;EAEhB;EAEA;;;EAGAK,WAAWA,CAAA;IACT,OAAO,IAAI,CAACC,SAAS,CAACC,QAAQ,EAAe;EAC/C;EAEA;;;;;EAKMC,kBAAkBA,CAACC,OAAoB,EAAEC,KAAe;IAAA,IAAAC,KAAA;IAAA,OAAAC,iBAAA;MAC5D,MAAMC,QAAQ,GAAGH,KAAK,CAACI,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC;MAE3C,IAAIC,cAAc,GAAGJ,KAAI,CAACL,SAAS,CAACC,QAAQ,EAAE;MAE9C,IAAIQ,cAAc,KAAK,IAAI,EAAE;QAC3B;QACA,IAAItB,SAAS,GAAkB,IAAIG,GAAG,EAAE;QAExC,IAAImB,cAAc,CAACC,MAAM,KAAK,CAAC,EAAE;UAC/B;UACA;UACA,IAAIC,SAAS,GAAGF,cAAc,CAACG,MAAM,CAAEC,OAAO,IAAI;YAChD,MAAMC,WAAW,GAAGD,OAAO,CAACV,OAAO,KAAKA,OAAO;YAC/C,MAAMY,SAAS,GAAGF,OAAO,CAACT,KAAK,CAACY,QAAQ,EAAE,KAAKZ,KAAK,CAACY,QAAQ,EAAE;YAE/D;YACA,OAAOF,WAAW,IAAIC,SAAS;UACjC,CAAC,CAAC;UAEF5B,SAAS,GAAGkB,KAAI,CAACY,oBAAoB,CAACN,SAAS,CAG9C;;QAGH;QACA,IAAIxB,SAAS,CAAC+B,IAAI,KAAK,CAAC,EAAE;UACxBC,OAAO,CAACC,GAAG,CAAC,gBAAgB,CAAC;UAC7BjC,SAAS,SAASkB,KAAI,CAACgB,oBAAoB,CAAClB,OAAO,EAAEC,KAAK,CAAC;SAC5D,MAAM;UACLe,OAAO,CAACC,GAAG,CAAC,SAAS,CAAC;;QAGxB;QACAf,KAAI,CAACnB,aAAa,CAACoC,IAAI,CAACnC,SAAS,CAAC;;IACnC;EACH;EAEA;;;EAGAoC,aAAaA,CACXC,QAAe,EACf/B,QAAiB,EACjBC,QAAiB;IAEjB,IAAI;MACF;MACA,MAAM+B,WAAW,GAAG,IAAI,CAAClC,aAAa,CACpCiC,QAAQ,EACR/B,QAAQ,EACRC,QAAQ,CACI;MACd;MACA,IAAI,CAAClB,iBAAiB,CAACkD,gBAAgB,CACrC,IAAI,CAACC,qBAAqB,CAACF,WAAW,CAAC,CACxC;MAED;MACA;MACA,IAAI,CAACG,WAAW,CAACH,WAAW,CAAC;MAE7B,OAAOA,WAAW;KACnB,CAAC,OAAOI,KAAK,EAAE;MACd,IAAI,CAACC,WAAW,CAAC,eAAe,EAAED,KAAK,EAAE,EAAE,EAAE,EAAE,CAAC;;EAEpD;EAEA;;;;;;EAMMR,oBAAoBA,CAAClB,OAAoB,EAAEC,KAAe;IAAA,IAAA2B,MAAA;IAAA,OAAAzB,iBAAA;MAC9DyB,MAAI,CAACC,WAAW,GAAGD,MAAI,CAAChD,KAAK,CAACgD,MAAI,CAAClD,gBAAgB,CAACoD,WAAW,CAAC;MAEhE,IAAIT,QAAQ,GAAG,EAAE;MAEjB,IAAIrB,OAAO,KAAK,SAAS,EAAE;QACzB;QACA;QACA;QACA;QACA;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,MAAM+B,YAAY,GAAG,OAAOH,MAAI,CAACC,WAAW,IAAI5B,KAAK,CAACI,QAAQ,CAC5D,QAAQ,CACT,EAAE;QACHgB,QAAQ,SAASO,MAAI,CAACI,kBAAkB,CAACD,YAAY,CAAC;QAEtD;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;OACD,MAAM,IAAI/B,OAAO,KAAK,SAAS,EAAE;QAChC;MAAA,CACD,MAAM;QACL4B,MAAI,CAACpD,cAAc,CAACyD,GAAG,CAACjC,OAAO,GAAG,qCAAqC,CAAC;;MAG1E;MACA,OAAO4B,MAAI,CAACd,oBAAoB,CAACO,QAAQ,CAAC;IAAC;EAC7C;EAEA;;;;;;EAMMW,kBAAkBA,CAACD,YAAoB,EAAEG,IAAe;IAAA,IAAAC,MAAA;IAAA,OAAAhC,iBAAA;MAC5D,MAAMiC,cAAc,GAAGD,MAAI,CAAC7D,cAAc,CAAC+D,eAAe,EAAE,CAACC,GAAG;MAChE,MAAMjD,aAAa,SAAS8C,MAAI,CAAC5D,WAAW,CAACgE,mBAAmB,CAC9DR,YAAY,EACZK,cAAc,CACf;MAED,OAAOD,MAAI,CAAC/C,aAAa,CACvBC,aAAa,EACb8C,MAAI,CAAC1D,WAAW,CAAC+D,QAAQ,EAAE,EAC3BL,MAAI,CAACxD,WAAW,CAAC8D,QAAQ,EAAE,CACf;IAAC;EACjB;EAEA9C,kBAAkBA,CAAI+C,YAAe;IACnC;IACAA,YAAY,CAAC,aAAa,CAAC,CAACC,OAAO,CAAC,CAACC,GAAG,EAAEC,KAAK,KAAI;MACjD;MACAH,YAAY,CAAC,aAAa,CAAC,CACzBG,KAAK,CACN,CAACC,IAAI,GAAG,IAAI,CAACrE,WAAW,CAACsE,wBAAwB,CAChDH,GAAG,CAACI,KAAK,EACTJ,GAAG,CAACK,WAAW,EACfL,GAAG,CAACM,WAAW,CAChB;IACH,CAAC,CAAC;IAEF,OAAOR,YAAY;EACrB;EAEA5B,oBAAoBA,CAACO,QAAa;IAChC,MAAM8B,YAAY,GAAG,IAAIhE,GAAG,EAAE;IAE9B,IAAIkC,QAAQ,KAAK,IAAI,EAAE;MACrBA,QAAQ,CAACsB,OAAO,CAAEjC,OAAO,IAAI;QAC3ByC,YAAY,CAACC,GAAG,CAAC1C,OAAO,CAAC4B,GAAG,EAAE5B,OAAO,CAAC;MACxC,CAAC,CAAC;;IAGJ,OAAOyC,YAAY;EACrB;EAEA;;;;;EAKA3B,qBAAqBA,CAACF,WAAsB;IAC1C,IAAI+B,CAAC,GAAG,EAAE;IACV/B,WAAW,CAACqB,OAAO,CAAEW,CAAC,IAAI;MACxB;MACA;MACA,MAAMC,KAAK,GAAGD,CAAC,CAACE,WAAW,CAAC/D,GAAG,CAAEmD,GAAG,IAAK,CAACA,GAAG,CAACa,GAAG,EAAEb,GAAG,CAAC,CAAC;MAExDS,CAAC,GAAGA,CAAC,CAACK,MAAM,CAACH,KAAK,CAAC;IACrB,CAAC,CAAC;IAEF,OAAO,IAAIpE,GAAG,CAACkE,CAAC,CAAC;EACnB;EAEA;EACA;;;;EAIMM,YAAYA,CAACtC,QAAmB;IAAA,IAAAuC,MAAA;IAAA,OAAAzD,iBAAA;MACpC,IAAI;QACF;QACA,MAAMyD,MAAI,CAACtF,cAAc,CAACuF,cAAc,CACtC,UAAU,EACVxC,QAAQ,EACR,KAAK,EACL,KAAK,EACL,IAAIpD,gBAAgB,EAAE,CACvB;QAED2F,MAAI,CAACpF,cAAc,CAACsF,YAAY,CAAC,sBAAsB,CAAC;OACzD,CAAC,OAAOpC,KAAK,EAAE;QACd;QACAkC,MAAI,CAACjC,WAAW,CAAM,aAAa,EAAED,KAAK,CAAC;;IAC5C;EACH;EAAC,QAAAqC,CAAA,G;qBAhSU5F,cAAc,EAAA6F,EAAA,CAAAC,QAAA,CAAAC,EAAA,CAAAC,iBAAA,GAAAH,EAAA,CAAAC,QAAA,CAAAG,EAAA,CAAAC,cAAA,GAAAL,EAAA,CAAAC,QAAA,CAAAK,EAAA,CAAAC,WAAA,GAAAP,EAAA,CAAAC,QAAA,CAAAO,EAAA,CAAAC,cAAA,GAAAT,EAAA,CAAAC,QAAA,CAAAS,EAAA,CAAAC,WAAA,GAAAX,EAAA,CAAAC,QAAA,CAAAW,EAAA,CAAAC,gBAAA,GAAAb,EAAA,CAAAC,QAAA,CAAAa,EAAA,CAAAC,WAAA;EAAA;EAAA,QAAAC,EAAA,G;WAAd7G,cAAc;IAAA8G,OAAA,EAAd9G,cAAc,CAAA+G,IAAA;IAAAC,UAAA,EAFb;EAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}