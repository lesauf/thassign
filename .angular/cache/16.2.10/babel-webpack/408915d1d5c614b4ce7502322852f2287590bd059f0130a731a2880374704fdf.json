{"ast":null,"code":"import { __values, __read, __awaiter, __generator, __spreadArray } from 'tslib';\nimport { Deferred } from '@firebase/util';\n\n/**\r\n * Component for service name T, e.g. `auth`, `auth-internal`\r\n */\nvar Component = /** @class */function () {\n  /**\r\n   *\r\n   * @param name The public service name, e.g. app, auth, firestore, database\r\n   * @param instanceFactory Service factory responsible for creating the public interface\r\n   * @param type whether the service provided by the component is public or private\r\n   */\n  function Component(name, instanceFactory, type) {\n    this.name = name;\n    this.instanceFactory = instanceFactory;\n    this.type = type;\n    this.multipleInstances = false;\n    /**\r\n     * Properties to be added to the service namespace\r\n     */\n    this.serviceProps = {};\n    this.instantiationMode = \"LAZY\" /* LAZY */;\n    this.onInstanceCreated = null;\n  }\n  Component.prototype.setInstantiationMode = function (mode) {\n    this.instantiationMode = mode;\n    return this;\n  };\n  Component.prototype.setMultipleInstances = function (multipleInstances) {\n    this.multipleInstances = multipleInstances;\n    return this;\n  };\n  Component.prototype.setServiceProps = function (props) {\n    this.serviceProps = props;\n    return this;\n  };\n  Component.prototype.setInstanceCreatedCallback = function (callback) {\n    this.onInstanceCreated = callback;\n    return this;\n  };\n  return Component;\n}();\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\r\n * NameServiceMapping[T] is an alias for the type of the instance\r\n */\nvar Provider = /** @class */function () {\n  function Provider(name, container) {\n    this.name = name;\n    this.container = container;\n    this.component = null;\n    this.instances = new Map();\n    this.instancesDeferred = new Map();\n    this.instancesOptions = new Map();\n    this.onInitCallbacks = new Map();\n  }\n  /**\r\n   * @param identifier A provider can provide mulitple instances of a service\r\n   * if this.component.multipleInstances is true.\r\n   */\n  Provider.prototype.get = function (identifier) {\n    // if multipleInstances is not supported, use the default name\n    var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n    if (!this.instancesDeferred.has(normalizedIdentifier)) {\n      var deferred = new Deferred();\n      this.instancesDeferred.set(normalizedIdentifier, deferred);\n      if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n        // initialize the service if it can be auto-initialized\n        try {\n          var instance = this.getOrInitializeService({\n            instanceIdentifier: normalizedIdentifier\n          });\n          if (instance) {\n            deferred.resolve(instance);\n          }\n        } catch (e) {\n          // when the instance factory throws an exception during get(), it should not cause\n          // a fatal error. We just return the unresolved promise in this case.\n        }\n      }\n    }\n    return this.instancesDeferred.get(normalizedIdentifier).promise;\n  };\n  Provider.prototype.getImmediate = function (options) {\n    var _a;\n    // if multipleInstances is not supported, use the default name\n    var normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\n    var optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\n    if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n      try {\n        return this.getOrInitializeService({\n          instanceIdentifier: normalizedIdentifier\n        });\n      } catch (e) {\n        if (optional) {\n          return null;\n        } else {\n          throw e;\n        }\n      }\n    } else {\n      // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw\n      if (optional) {\n        return null;\n      } else {\n        throw Error(\"Service \" + this.name + \" is not available\");\n      }\n    }\n  };\n  Provider.prototype.getComponent = function () {\n    return this.component;\n  };\n  Provider.prototype.setComponent = function (component) {\n    var e_1, _a;\n    if (component.name !== this.name) {\n      throw Error(\"Mismatching Component \" + component.name + \" for Provider \" + this.name + \".\");\n    }\n    if (this.component) {\n      throw Error(\"Component for \" + this.name + \" has already been provided\");\n    }\n    this.component = component;\n    // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\n    if (!this.shouldAutoInitialize()) {\n      return;\n    }\n    // if the service is eager, initialize the default instance\n    if (isComponentEager(component)) {\n      try {\n        this.getOrInitializeService({\n          instanceIdentifier: DEFAULT_ENTRY_NAME\n        });\n      } catch (e) {\n        // when the instance factory for an eager Component throws an exception during the eager\n        // initialization, it should not cause a fatal error.\n        // TODO: Investigate if we need to make it configurable, because some component may want to cause\n        // a fatal error in this case?\n      }\n    }\n    try {\n      // Create service instances for the pending promises and resolve them\n      // NOTE: if this.multipleInstances is false, only the default instance will be created\n      // and all promises with resolve with it regardless of the identifier.\n      for (var _b = __values(this.instancesDeferred.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var _d = __read(_c.value, 2),\n          instanceIdentifier = _d[0],\n          instanceDeferred = _d[1];\n        var normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n        try {\n          // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\n          var instance = this.getOrInitializeService({\n            instanceIdentifier: normalizedIdentifier\n          });\n          instanceDeferred.resolve(instance);\n        } catch (e) {\n          // when the instance factory throws an exception, it should not cause\n          // a fatal error. We just leave the promise unresolved.\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n  Provider.prototype.clearInstance = function (identifier) {\n    if (identifier === void 0) {\n      identifier = DEFAULT_ENTRY_NAME;\n    }\n    this.instancesDeferred.delete(identifier);\n    this.instancesOptions.delete(identifier);\n    this.instances.delete(identifier);\n  };\n  // app.delete() will call this method on every provider to delete the services\n  // TODO: should we mark the provider as deleted?\n  Provider.prototype.delete = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var services;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            services = Array.from(this.instances.values());\n            return [4 /*yield*/, Promise.all(__spreadArray(__spreadArray([], __read(services.filter(function (service) {\n              return 'INTERNAL' in service;\n            }) // legacy services\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            .map(function (service) {\n              return service.INTERNAL.delete();\n            }))), __read(services.filter(function (service) {\n              return '_delete' in service;\n            }) // modularized services\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            .map(function (service) {\n              return service._delete();\n            }))))];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  Provider.prototype.isComponentSet = function () {\n    return this.component != null;\n  };\n  Provider.prototype.isInitialized = function (identifier) {\n    if (identifier === void 0) {\n      identifier = DEFAULT_ENTRY_NAME;\n    }\n    return this.instances.has(identifier);\n  };\n  Provider.prototype.getOptions = function (identifier) {\n    if (identifier === void 0) {\n      identifier = DEFAULT_ENTRY_NAME;\n    }\n    return this.instancesOptions.get(identifier) || {};\n  };\n  Provider.prototype.initialize = function (opts) {\n    var e_2, _a;\n    if (opts === void 0) {\n      opts = {};\n    }\n    var _b = opts.options,\n      options = _b === void 0 ? {} : _b;\n    var normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\n    if (this.isInitialized(normalizedIdentifier)) {\n      throw Error(this.name + \"(\" + normalizedIdentifier + \") has already been initialized\");\n    }\n    if (!this.isComponentSet()) {\n      throw Error(\"Component \" + this.name + \" has not been registered yet\");\n    }\n    var instance = this.getOrInitializeService({\n      instanceIdentifier: normalizedIdentifier,\n      options: options\n    });\n    try {\n      // resolve any pending promise waiting for the service instance\n      for (var _c = __values(this.instancesDeferred.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var _e = __read(_d.value, 2),\n          instanceIdentifier = _e[0],\n          instanceDeferred = _e[1];\n        var normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n        if (normalizedIdentifier === normalizedDeferredIdentifier) {\n          instanceDeferred.resolve(instance);\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    return instance;\n  };\n  /**\r\n   *\r\n   * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\r\n   * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\r\n   *\r\n   * @param identifier An optional instance identifier\r\n   * @returns a function to unregister the callback\r\n   */\n  Provider.prototype.onInit = function (callback, identifier) {\n    var _a;\n    var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n    var existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\n    existingCallbacks.add(callback);\n    this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\n    var existingInstance = this.instances.get(normalizedIdentifier);\n    if (existingInstance) {\n      callback(existingInstance, normalizedIdentifier);\n    }\n    return function () {\n      existingCallbacks.delete(callback);\n    };\n  };\n  /**\r\n   * Invoke onInit callbacks synchronously\r\n   * @param instance the service instance`\r\n   */\n  Provider.prototype.invokeOnInitCallbacks = function (instance, identifier) {\n    var e_3, _a;\n    var callbacks = this.onInitCallbacks.get(identifier);\n    if (!callbacks) {\n      return;\n    }\n    try {\n      for (var callbacks_1 = __values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {\n        var callback = callbacks_1_1.value;\n        try {\n          callback(instance, identifier);\n        } catch (_b) {\n          // ignore errors in the onInit callback\n        }\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n  };\n  Provider.prototype.getOrInitializeService = function (_a) {\n    var instanceIdentifier = _a.instanceIdentifier,\n      _b = _a.options,\n      options = _b === void 0 ? {} : _b;\n    var instance = this.instances.get(instanceIdentifier);\n    if (!instance && this.component) {\n      instance = this.component.instanceFactory(this.container, {\n        instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\n        options: options\n      });\n      this.instances.set(instanceIdentifier, instance);\n      this.instancesOptions.set(instanceIdentifier, options);\n      /**\r\n       * Invoke onInit listeners.\r\n       * Note this.component.onInstanceCreated is different, which is used by the component creator,\r\n       * while onInit listeners are registered by consumers of the provider.\r\n       */\n      this.invokeOnInitCallbacks(instance, instanceIdentifier);\n      /**\r\n       * Order is important\r\n       * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\r\n       * makes `isInitialized()` return true.\r\n       */\n      if (this.component.onInstanceCreated) {\n        try {\n          this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\n        } catch (_c) {\n          // ignore errors in the onInstanceCreatedCallback\n        }\n      }\n    }\n    return instance || null;\n  };\n  Provider.prototype.normalizeInstanceIdentifier = function (identifier) {\n    if (identifier === void 0) {\n      identifier = DEFAULT_ENTRY_NAME;\n    }\n    if (this.component) {\n      return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\n    } else {\n      return identifier; // assume multiple instances are supported before the component is provided.\n    }\n  };\n\n  Provider.prototype.shouldAutoInitialize = function () {\n    return !!this.component && this.component.instantiationMode !== \"EXPLICIT\" /* EXPLICIT */;\n  };\n\n  return Provider;\n}();\n// undefined should be passed to the service factory for the default instance\nfunction normalizeIdentifierForFactory(identifier) {\n  return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\n}\nfunction isComponentEager(component) {\n  return component.instantiationMode === \"EAGER\" /* EAGER */;\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\r\n */\nvar ComponentContainer = /** @class */function () {\n  function ComponentContainer(name) {\n    this.name = name;\n    this.providers = new Map();\n  }\n  /**\r\n   *\r\n   * @param component Component being added\r\n   * @param overwrite When a component with the same name has already been registered,\r\n   * if overwrite is true: overwrite the existing component with the new component and create a new\r\n   * provider with the new component. It can be useful in tests where you want to use different mocks\r\n   * for different tests.\r\n   * if overwrite is false: throw an exception\r\n   */\n  ComponentContainer.prototype.addComponent = function (component) {\n    var provider = this.getProvider(component.name);\n    if (provider.isComponentSet()) {\n      throw new Error(\"Component \" + component.name + \" has already been registered with \" + this.name);\n    }\n    provider.setComponent(component);\n  };\n  ComponentContainer.prototype.addOrOverwriteComponent = function (component) {\n    var provider = this.getProvider(component.name);\n    if (provider.isComponentSet()) {\n      // delete the existing provider from the container, so we can register the new component\n      this.providers.delete(component.name);\n    }\n    this.addComponent(component);\n  };\n  /**\r\n   * getProvider provides a type safe interface where it can only be called with a field name\r\n   * present in NameServiceMapping interface.\r\n   *\r\n   * Firebase SDKs providing services should extend NameServiceMapping interface to register\r\n   * themselves.\r\n   */\n  ComponentContainer.prototype.getProvider = function (name) {\n    if (this.providers.has(name)) {\n      return this.providers.get(name);\n    }\n    // create a Provider for a service that hasn't registered with Firebase\n    var provider = new Provider(name, this);\n    this.providers.set(name, provider);\n    return provider;\n  };\n  ComponentContainer.prototype.getProviders = function () {\n    return Array.from(this.providers.values());\n  };\n  return ComponentContainer;\n}();\nexport { Component, ComponentContainer, Provider };","map":{"version":3,"names":["__values","__read","__awaiter","__generator","__spreadArray","Deferred","Component","name","instanceFactory","type","multipleInstances","serviceProps","instantiationMode","onInstanceCreated","prototype","setInstantiationMode","mode","setMultipleInstances","setServiceProps","props","setInstanceCreatedCallback","callback","DEFAULT_ENTRY_NAME","Provider","container","component","instances","Map","instancesDeferred","instancesOptions","onInitCallbacks","get","identifier","normalizedIdentifier","normalizeInstanceIdentifier","has","deferred","set","isInitialized","shouldAutoInitialize","instance","getOrInitializeService","instanceIdentifier","resolve","e","promise","getImmediate","options","_a","optional","Error","getComponent","setComponent","e_1","isComponentEager","_b","entries","_c","next","done","_d","value","instanceDeferred","e_1_1","error","return","call","clearInstance","delete","services","label","Array","from","values","Promise","all","filter","service","map","INTERNAL","_delete","sent","isComponentSet","getOptions","initialize","opts","e_2","_e","normalizedDeferredIdentifier","e_2_1","onInit","existingCallbacks","Set","add","existingInstance","invokeOnInitCallbacks","e_3","callbacks","callbacks_1","callbacks_1_1","e_3_1","normalizeIdentifierForFactory","undefined","ComponentContainer","providers","addComponent","provider","getProvider","addOrOverwriteComponent","getProviders"],"sources":["C:/Users/CSEG/Desktop/thassign/node_modules/@firebase/component/dist/index.esm.js"],"sourcesContent":["import { __values, __read, __awaiter, __generator, __spreadArray } from 'tslib';\nimport { Deferred } from '@firebase/util';\n\n/**\r\n * Component for service name T, e.g. `auth`, `auth-internal`\r\n */\r\nvar Component = /** @class */ (function () {\r\n    /**\r\n     *\r\n     * @param name The public service name, e.g. app, auth, firestore, database\r\n     * @param instanceFactory Service factory responsible for creating the public interface\r\n     * @param type whether the service provided by the component is public or private\r\n     */\r\n    function Component(name, instanceFactory, type) {\r\n        this.name = name;\r\n        this.instanceFactory = instanceFactory;\r\n        this.type = type;\r\n        this.multipleInstances = false;\r\n        /**\r\n         * Properties to be added to the service namespace\r\n         */\r\n        this.serviceProps = {};\r\n        this.instantiationMode = \"LAZY\" /* LAZY */;\r\n        this.onInstanceCreated = null;\r\n    }\r\n    Component.prototype.setInstantiationMode = function (mode) {\r\n        this.instantiationMode = mode;\r\n        return this;\r\n    };\r\n    Component.prototype.setMultipleInstances = function (multipleInstances) {\r\n        this.multipleInstances = multipleInstances;\r\n        return this;\r\n    };\r\n    Component.prototype.setServiceProps = function (props) {\r\n        this.serviceProps = props;\r\n        return this;\r\n    };\r\n    Component.prototype.setInstanceCreatedCallback = function (callback) {\r\n        this.onInstanceCreated = callback;\r\n        return this;\r\n    };\r\n    return Component;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\r\n * NameServiceMapping[T] is an alias for the type of the instance\r\n */\r\nvar Provider = /** @class */ (function () {\r\n    function Provider(name, container) {\r\n        this.name = name;\r\n        this.container = container;\r\n        this.component = null;\r\n        this.instances = new Map();\r\n        this.instancesDeferred = new Map();\r\n        this.instancesOptions = new Map();\r\n        this.onInitCallbacks = new Map();\r\n    }\r\n    /**\r\n     * @param identifier A provider can provide mulitple instances of a service\r\n     * if this.component.multipleInstances is true.\r\n     */\r\n    Provider.prototype.get = function (identifier) {\r\n        // if multipleInstances is not supported, use the default name\r\n        var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\r\n        if (!this.instancesDeferred.has(normalizedIdentifier)) {\r\n            var deferred = new Deferred();\r\n            this.instancesDeferred.set(normalizedIdentifier, deferred);\r\n            if (this.isInitialized(normalizedIdentifier) ||\r\n                this.shouldAutoInitialize()) {\r\n                // initialize the service if it can be auto-initialized\r\n                try {\r\n                    var instance = this.getOrInitializeService({\r\n                        instanceIdentifier: normalizedIdentifier\r\n                    });\r\n                    if (instance) {\r\n                        deferred.resolve(instance);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    // when the instance factory throws an exception during get(), it should not cause\r\n                    // a fatal error. We just return the unresolved promise in this case.\r\n                }\r\n            }\r\n        }\r\n        return this.instancesDeferred.get(normalizedIdentifier).promise;\r\n    };\r\n    Provider.prototype.getImmediate = function (options) {\r\n        var _a;\r\n        // if multipleInstances is not supported, use the default name\r\n        var normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\r\n        var optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\r\n        if (this.isInitialized(normalizedIdentifier) ||\r\n            this.shouldAutoInitialize()) {\r\n            try {\r\n                return this.getOrInitializeService({\r\n                    instanceIdentifier: normalizedIdentifier\r\n                });\r\n            }\r\n            catch (e) {\r\n                if (optional) {\r\n                    return null;\r\n                }\r\n                else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw\r\n            if (optional) {\r\n                return null;\r\n            }\r\n            else {\r\n                throw Error(\"Service \" + this.name + \" is not available\");\r\n            }\r\n        }\r\n    };\r\n    Provider.prototype.getComponent = function () {\r\n        return this.component;\r\n    };\r\n    Provider.prototype.setComponent = function (component) {\r\n        var e_1, _a;\r\n        if (component.name !== this.name) {\r\n            throw Error(\"Mismatching Component \" + component.name + \" for Provider \" + this.name + \".\");\r\n        }\r\n        if (this.component) {\r\n            throw Error(\"Component for \" + this.name + \" has already been provided\");\r\n        }\r\n        this.component = component;\r\n        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\r\n        if (!this.shouldAutoInitialize()) {\r\n            return;\r\n        }\r\n        // if the service is eager, initialize the default instance\r\n        if (isComponentEager(component)) {\r\n            try {\r\n                this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });\r\n            }\r\n            catch (e) {\r\n                // when the instance factory for an eager Component throws an exception during the eager\r\n                // initialization, it should not cause a fatal error.\r\n                // TODO: Investigate if we need to make it configurable, because some component may want to cause\r\n                // a fatal error in this case?\r\n            }\r\n        }\r\n        try {\r\n            // Create service instances for the pending promises and resolve them\r\n            // NOTE: if this.multipleInstances is false, only the default instance will be created\r\n            // and all promises with resolve with it regardless of the identifier.\r\n            for (var _b = __values(this.instancesDeferred.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var _d = __read(_c.value, 2), instanceIdentifier = _d[0], instanceDeferred = _d[1];\r\n                var normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\r\n                try {\r\n                    // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\r\n                    var instance = this.getOrInitializeService({\r\n                        instanceIdentifier: normalizedIdentifier\r\n                    });\r\n                    instanceDeferred.resolve(instance);\r\n                }\r\n                catch (e) {\r\n                    // when the instance factory throws an exception, it should not cause\r\n                    // a fatal error. We just leave the promise unresolved.\r\n                }\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n    };\r\n    Provider.prototype.clearInstance = function (identifier) {\r\n        if (identifier === void 0) { identifier = DEFAULT_ENTRY_NAME; }\r\n        this.instancesDeferred.delete(identifier);\r\n        this.instancesOptions.delete(identifier);\r\n        this.instances.delete(identifier);\r\n    };\r\n    // app.delete() will call this method on every provider to delete the services\r\n    // TODO: should we mark the provider as deleted?\r\n    Provider.prototype.delete = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var services;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        services = Array.from(this.instances.values());\r\n                        return [4 /*yield*/, Promise.all(__spreadArray(__spreadArray([], __read(services\r\n                                .filter(function (service) { return 'INTERNAL' in service; }) // legacy services\r\n                                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                                .map(function (service) { return service.INTERNAL.delete(); }))), __read(services\r\n                                .filter(function (service) { return '_delete' in service; }) // modularized services\r\n                                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                                .map(function (service) { return service._delete(); }))))];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Provider.prototype.isComponentSet = function () {\r\n        return this.component != null;\r\n    };\r\n    Provider.prototype.isInitialized = function (identifier) {\r\n        if (identifier === void 0) { identifier = DEFAULT_ENTRY_NAME; }\r\n        return this.instances.has(identifier);\r\n    };\r\n    Provider.prototype.getOptions = function (identifier) {\r\n        if (identifier === void 0) { identifier = DEFAULT_ENTRY_NAME; }\r\n        return this.instancesOptions.get(identifier) || {};\r\n    };\r\n    Provider.prototype.initialize = function (opts) {\r\n        var e_2, _a;\r\n        if (opts === void 0) { opts = {}; }\r\n        var _b = opts.options, options = _b === void 0 ? {} : _b;\r\n        var normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\r\n        if (this.isInitialized(normalizedIdentifier)) {\r\n            throw Error(this.name + \"(\" + normalizedIdentifier + \") has already been initialized\");\r\n        }\r\n        if (!this.isComponentSet()) {\r\n            throw Error(\"Component \" + this.name + \" has not been registered yet\");\r\n        }\r\n        var instance = this.getOrInitializeService({\r\n            instanceIdentifier: normalizedIdentifier,\r\n            options: options\r\n        });\r\n        try {\r\n            // resolve any pending promise waiting for the service instance\r\n            for (var _c = __values(this.instancesDeferred.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {\r\n                var _e = __read(_d.value, 2), instanceIdentifier = _e[0], instanceDeferred = _e[1];\r\n                var normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\r\n                if (normalizedIdentifier === normalizedDeferredIdentifier) {\r\n                    instanceDeferred.resolve(instance);\r\n                }\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n        return instance;\r\n    };\r\n    /**\r\n     *\r\n     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\r\n     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\r\n     *\r\n     * @param identifier An optional instance identifier\r\n     * @returns a function to unregister the callback\r\n     */\r\n    Provider.prototype.onInit = function (callback, identifier) {\r\n        var _a;\r\n        var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\r\n        var existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\r\n        existingCallbacks.add(callback);\r\n        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\r\n        var existingInstance = this.instances.get(normalizedIdentifier);\r\n        if (existingInstance) {\r\n            callback(existingInstance, normalizedIdentifier);\r\n        }\r\n        return function () {\r\n            existingCallbacks.delete(callback);\r\n        };\r\n    };\r\n    /**\r\n     * Invoke onInit callbacks synchronously\r\n     * @param instance the service instance`\r\n     */\r\n    Provider.prototype.invokeOnInitCallbacks = function (instance, identifier) {\r\n        var e_3, _a;\r\n        var callbacks = this.onInitCallbacks.get(identifier);\r\n        if (!callbacks) {\r\n            return;\r\n        }\r\n        try {\r\n            for (var callbacks_1 = __values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {\r\n                var callback = callbacks_1_1.value;\r\n                try {\r\n                    callback(instance, identifier);\r\n                }\r\n                catch (_b) {\r\n                    // ignore errors in the onInit callback\r\n                }\r\n            }\r\n        }\r\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n        finally {\r\n            try {\r\n                if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);\r\n            }\r\n            finally { if (e_3) throw e_3.error; }\r\n        }\r\n    };\r\n    Provider.prototype.getOrInitializeService = function (_a) {\r\n        var instanceIdentifier = _a.instanceIdentifier, _b = _a.options, options = _b === void 0 ? {} : _b;\r\n        var instance = this.instances.get(instanceIdentifier);\r\n        if (!instance && this.component) {\r\n            instance = this.component.instanceFactory(this.container, {\r\n                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\r\n                options: options\r\n            });\r\n            this.instances.set(instanceIdentifier, instance);\r\n            this.instancesOptions.set(instanceIdentifier, options);\r\n            /**\r\n             * Invoke onInit listeners.\r\n             * Note this.component.onInstanceCreated is different, which is used by the component creator,\r\n             * while onInit listeners are registered by consumers of the provider.\r\n             */\r\n            this.invokeOnInitCallbacks(instance, instanceIdentifier);\r\n            /**\r\n             * Order is important\r\n             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\r\n             * makes `isInitialized()` return true.\r\n             */\r\n            if (this.component.onInstanceCreated) {\r\n                try {\r\n                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\r\n                }\r\n                catch (_c) {\r\n                    // ignore errors in the onInstanceCreatedCallback\r\n                }\r\n            }\r\n        }\r\n        return instance || null;\r\n    };\r\n    Provider.prototype.normalizeInstanceIdentifier = function (identifier) {\r\n        if (identifier === void 0) { identifier = DEFAULT_ENTRY_NAME; }\r\n        if (this.component) {\r\n            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\r\n        }\r\n        else {\r\n            return identifier; // assume multiple instances are supported before the component is provided.\r\n        }\r\n    };\r\n    Provider.prototype.shouldAutoInitialize = function () {\r\n        return (!!this.component &&\r\n            this.component.instantiationMode !== \"EXPLICIT\" /* EXPLICIT */);\r\n    };\r\n    return Provider;\r\n}());\r\n// undefined should be passed to the service factory for the default instance\r\nfunction normalizeIdentifierForFactory(identifier) {\r\n    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\r\n}\r\nfunction isComponentEager(component) {\r\n    return component.instantiationMode === \"EAGER\" /* EAGER */;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\r\n */\r\nvar ComponentContainer = /** @class */ (function () {\r\n    function ComponentContainer(name) {\r\n        this.name = name;\r\n        this.providers = new Map();\r\n    }\r\n    /**\r\n     *\r\n     * @param component Component being added\r\n     * @param overwrite When a component with the same name has already been registered,\r\n     * if overwrite is true: overwrite the existing component with the new component and create a new\r\n     * provider with the new component. It can be useful in tests where you want to use different mocks\r\n     * for different tests.\r\n     * if overwrite is false: throw an exception\r\n     */\r\n    ComponentContainer.prototype.addComponent = function (component) {\r\n        var provider = this.getProvider(component.name);\r\n        if (provider.isComponentSet()) {\r\n            throw new Error(\"Component \" + component.name + \" has already been registered with \" + this.name);\r\n        }\r\n        provider.setComponent(component);\r\n    };\r\n    ComponentContainer.prototype.addOrOverwriteComponent = function (component) {\r\n        var provider = this.getProvider(component.name);\r\n        if (provider.isComponentSet()) {\r\n            // delete the existing provider from the container, so we can register the new component\r\n            this.providers.delete(component.name);\r\n        }\r\n        this.addComponent(component);\r\n    };\r\n    /**\r\n     * getProvider provides a type safe interface where it can only be called with a field name\r\n     * present in NameServiceMapping interface.\r\n     *\r\n     * Firebase SDKs providing services should extend NameServiceMapping interface to register\r\n     * themselves.\r\n     */\r\n    ComponentContainer.prototype.getProvider = function (name) {\r\n        if (this.providers.has(name)) {\r\n            return this.providers.get(name);\r\n        }\r\n        // create a Provider for a service that hasn't registered with Firebase\r\n        var provider = new Provider(name, this);\r\n        this.providers.set(name, provider);\r\n        return provider;\r\n    };\r\n    ComponentContainer.prototype.getProviders = function () {\r\n        return Array.from(this.providers.values());\r\n    };\r\n    return ComponentContainer;\r\n}());\n\nexport { Component, ComponentContainer, Provider };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}