{"ast":null,"code":"import { DateTime, Interval } from 'luxon';\nimport { BehaviorSubject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@ngx-translate/core\";\nexport class TranslateDatePipe {\n  /**\r\n   * MomentPipe constructor\r\n   */\n  constructor(translate) {\n    this.translate = translate;\n    /**\r\n     * Custom date formats\r\n     */\n    this.dateFormats = {\n      'M-DD': {\n        month: 'short',\n        day: '2-digit'\n      },\n      'MM-DD': {\n        month: 'medium',\n        day: '2-digit'\n      },\n      'MMM-DD': {\n        month: 'long',\n        day: '2-digit'\n      },\n      'M-D': {\n        month: 'short',\n        day: 'numeric'\n      },\n      'MM-D': {\n        month: 'medium',\n        day: 'numeric'\n      },\n      'MMM-D': {\n        month: 'long',\n        day: 'numeric'\n      }\n    };\n  }\n  /**\r\n   * Make Date dynamic\r\n   * @param format one of the DateTime format constants\r\n   * @param intervalDisplay an object defining ho to calculate the\r\n   */\n  transform(value, format, intervalDisplay) {\n    // make the Date format configurable\n    if (format !== undefined) {\n      // if not one of DateTime constant, use my own\n      format = DateTime.hasOwnProperty(format) ? DateTime[format] : this.dateFormats[format];\n    } else {\n      format = DateTime['DATETIME_SHORT'];\n    }\n    // Initial display of Date.\n    // Insert the value into a new behaviour subject. If the language changes,\n    // the behaviour subject will be updated\n    const dateObs = new BehaviorSubject(this.format(value, format, intervalDisplay));\n    this.translate.onLangChange.subscribe(() => {\n      // Rebuild the display of date\n      dateObs.next(this.format(value, format, intervalDisplay));\n    });\n    return dateObs; // needs to be piped into the async pipe\n  }\n  /**\r\n   * Handle the generation of the date string\r\n   */\n  format(dateVal, format, intervalDisplay) {\n    let dateString;\n    // get the initial value and whether it is an interval\n    if (Interval.isInterval(dateVal)) {\n      // Setting the locale to both ends of the interval\n      dateVal = dateVal.mapEndpoints(endPoint => endPoint.setLocale(this.translate.currentLang));\n      // building the interval string\n      dateString = dateVal.start.toLocaleString(format) + ' - ' + dateVal.end.toLocaleString(format);\n    } else {\n      if (DateTime.isDateTime(dateVal)) {\n        dateVal.setLocale(this.translate.currentLang);\n        dateString = dateVal.toLocaleString(format);\n      } else {\n        dateVal = DateTime.fromISO(dateVal).setLocale(this.translate.currentLang);\n        dateString = dateVal.toLocaleString(format);\n      }\n      if (intervalDisplay !== undefined) {\n        const intervalEnd = dateVal.plus(intervalDisplay).toLocaleString(format);\n        dateString = dateString + ' - ' + intervalEnd;\n      }\n    }\n    return dateString;\n  }\n  static #_ = this.ɵfac = function TranslateDatePipe_Factory(t) {\n    return new (t || TranslateDatePipe)(i0.ɵɵdirectiveInject(i1.TranslateService, 16));\n  };\n  static #_2 = this.ɵpipe = /*@__PURE__*/i0.ɵɵdefinePipe({\n    name: \"translateDate\",\n    type: TranslateDatePipe,\n    pure: true\n  });\n}","map":{"version":3,"names":["DateTime","Interval","BehaviorSubject","TranslateDatePipe","constructor","translate","dateFormats","month","day","transform","value","format","intervalDisplay","undefined","hasOwnProperty","dateObs","onLangChange","subscribe","next","dateVal","dateString","isInterval","mapEndpoints","endPoint","setLocale","currentLang","start","toLocaleString","end","isDateTime","fromISO","intervalEnd","plus","_","i0","ɵɵdirectiveInject","i1","TranslateService","_2","pure"],"sources":["C:\\Users\\CSEG\\Desktop\\thassign\\src\\app\\shared\\pipes\\translate-date.pipe.ts"],"sourcesContent":["import { PipeTransform, Pipe } from '@angular/core';\r\nimport { TranslateService } from '@ngx-translate/core';\r\nimport { DateTime, Interval } from 'luxon';\r\nimport { BehaviorSubject } from 'rxjs';\r\n\r\n@Pipe({\r\n  name: 'translateDate',\r\n})\r\nexport class TranslateDatePipe implements PipeTransform {\r\n  /**\r\n   * Custom date formats\r\n   */\r\n  dateFormats = {\r\n    'M-DD': {\r\n      month: 'short',\r\n      day: '2-digit',\r\n    },\r\n    'MM-DD': {\r\n      month: 'medium',\r\n      day: '2-digit',\r\n    },\r\n    'MMM-DD': {\r\n      month: 'long',\r\n      day: '2-digit',\r\n    },\r\n    'M-D': {\r\n      month: 'short',\r\n      day: 'numeric',\r\n    },\r\n    'MM-D': {\r\n      month: 'medium',\r\n      day: 'numeric',\r\n    },\r\n    'MMM-D': {\r\n      month: 'long',\r\n      day: 'numeric',\r\n    },\r\n  };\r\n  /**\r\n   * MomentPipe constructor\r\n   */\r\n  constructor(private translate: TranslateService) {}\r\n\r\n  /**\r\n   * Make Date dynamic\r\n   * @param format one of the DateTime format constants\r\n   * @param intervalDisplay an object defining ho to calculate the\r\n   */\r\n  transform(\r\n    value: DateTime | Interval | string,\r\n    format?: any,\r\n    intervalDisplay?: object\r\n  ): any {\r\n    // make the Date format configurable\r\n    if (format !== undefined) {\r\n      // if not one of DateTime constant, use my own\r\n      format = DateTime.hasOwnProperty(format)\r\n        ? DateTime[format]\r\n        : this.dateFormats[format];\r\n    } else {\r\n      format = DateTime['DATETIME_SHORT'];\r\n    }\r\n\r\n    // Initial display of Date.\r\n    // Insert the value into a new behaviour subject. If the language changes,\r\n    // the behaviour subject will be updated\r\n    const dateObs = new BehaviorSubject<string>(\r\n      this.format(value, format, intervalDisplay)\r\n    );\r\n\r\n    this.translate.onLangChange.subscribe(() => {\r\n      // Rebuild the display of date\r\n      dateObs.next(this.format(value, format, intervalDisplay));\r\n    });\r\n\r\n    return dateObs; // needs to be piped into the async pipe\r\n  }\r\n\r\n  /**\r\n   * Handle the generation of the date string\r\n   */\r\n  format(\r\n    dateVal: DateTime | Interval | string,\r\n    format: any,\r\n    intervalDisplay?: object\r\n  ) {\r\n    let dateString: string;\r\n\r\n    // get the initial value and whether it is an interval\r\n    if (Interval.isInterval(dateVal)) {\r\n      // Setting the locale to both ends of the interval\r\n      dateVal = dateVal.mapEndpoints((endPoint) =>\r\n        endPoint.setLocale(this.translate.currentLang)\r\n      );\r\n\r\n      // building the interval string\r\n      dateString =\r\n        dateVal.start.toLocaleString(format) +\r\n        ' - ' +\r\n        dateVal.end.toLocaleString(format);\r\n    } else {\r\n      if (DateTime.isDateTime(dateVal)) {\r\n        dateVal.setLocale(this.translate.currentLang);\r\n\r\n        dateString = dateVal.toLocaleString(format);\r\n      } else {\r\n        dateVal = DateTime.fromISO(dateVal).setLocale(\r\n          this.translate.currentLang\r\n        );\r\n        dateString = dateVal.toLocaleString(format);\r\n      }\r\n\r\n      if (intervalDisplay !== undefined) {\r\n        const intervalEnd = dateVal\r\n          .plus(intervalDisplay)\r\n          .toLocaleString(format);\r\n        dateString = dateString + ' - ' + intervalEnd;\r\n      }\r\n    }\r\n\r\n    return dateString;\r\n  }\r\n}\r\n"],"mappings":"AAEA,SAASA,QAAQ,EAAEC,QAAQ,QAAQ,OAAO;AAC1C,SAASC,eAAe,QAAQ,MAAM;;;AAKtC,OAAM,MAAOC,iBAAiB;EA8B5B;;;EAGAC,YAAoBC,SAA2B;IAA3B,KAAAA,SAAS,GAATA,SAAS;IAhC7B;;;IAGA,KAAAC,WAAW,GAAG;MACZ,MAAM,EAAE;QACNC,KAAK,EAAE,OAAO;QACdC,GAAG,EAAE;OACN;MACD,OAAO,EAAE;QACPD,KAAK,EAAE,QAAQ;QACfC,GAAG,EAAE;OACN;MACD,QAAQ,EAAE;QACRD,KAAK,EAAE,MAAM;QACbC,GAAG,EAAE;OACN;MACD,KAAK,EAAE;QACLD,KAAK,EAAE,OAAO;QACdC,GAAG,EAAE;OACN;MACD,MAAM,EAAE;QACND,KAAK,EAAE,QAAQ;QACfC,GAAG,EAAE;OACN;MACD,OAAO,EAAE;QACPD,KAAK,EAAE,MAAM;QACbC,GAAG,EAAE;;KAER;EAIiD;EAElD;;;;;EAKAC,SAASA,CACPC,KAAmC,EACnCC,MAAY,EACZC,eAAwB;IAExB;IACA,IAAID,MAAM,KAAKE,SAAS,EAAE;MACxB;MACAF,MAAM,GAAGX,QAAQ,CAACc,cAAc,CAACH,MAAM,CAAC,GACpCX,QAAQ,CAACW,MAAM,CAAC,GAChB,IAAI,CAACL,WAAW,CAACK,MAAM,CAAC;KAC7B,MAAM;MACLA,MAAM,GAAGX,QAAQ,CAAC,gBAAgB,CAAC;;IAGrC;IACA;IACA;IACA,MAAMe,OAAO,GAAG,IAAIb,eAAe,CACjC,IAAI,CAACS,MAAM,CAACD,KAAK,EAAEC,MAAM,EAAEC,eAAe,CAAC,CAC5C;IAED,IAAI,CAACP,SAAS,CAACW,YAAY,CAACC,SAAS,CAAC,MAAK;MACzC;MACAF,OAAO,CAACG,IAAI,CAAC,IAAI,CAACP,MAAM,CAACD,KAAK,EAAEC,MAAM,EAAEC,eAAe,CAAC,CAAC;IAC3D,CAAC,CAAC;IAEF,OAAOG,OAAO,CAAC,CAAC;EAClB;EAEA;;;EAGAJ,MAAMA,CACJQ,OAAqC,EACrCR,MAAW,EACXC,eAAwB;IAExB,IAAIQ,UAAkB;IAEtB;IACA,IAAInB,QAAQ,CAACoB,UAAU,CAACF,OAAO,CAAC,EAAE;MAChC;MACAA,OAAO,GAAGA,OAAO,CAACG,YAAY,CAAEC,QAAQ,IACtCA,QAAQ,CAACC,SAAS,CAAC,IAAI,CAACnB,SAAS,CAACoB,WAAW,CAAC,CAC/C;MAED;MACAL,UAAU,GACRD,OAAO,CAACO,KAAK,CAACC,cAAc,CAAChB,MAAM,CAAC,GACpC,KAAK,GACLQ,OAAO,CAACS,GAAG,CAACD,cAAc,CAAChB,MAAM,CAAC;KACrC,MAAM;MACL,IAAIX,QAAQ,CAAC6B,UAAU,CAACV,OAAO,CAAC,EAAE;QAChCA,OAAO,CAACK,SAAS,CAAC,IAAI,CAACnB,SAAS,CAACoB,WAAW,CAAC;QAE7CL,UAAU,GAAGD,OAAO,CAACQ,cAAc,CAAChB,MAAM,CAAC;OAC5C,MAAM;QACLQ,OAAO,GAAGnB,QAAQ,CAAC8B,OAAO,CAACX,OAAO,CAAC,CAACK,SAAS,CAC3C,IAAI,CAACnB,SAAS,CAACoB,WAAW,CAC3B;QACDL,UAAU,GAAGD,OAAO,CAACQ,cAAc,CAAChB,MAAM,CAAC;;MAG7C,IAAIC,eAAe,KAAKC,SAAS,EAAE;QACjC,MAAMkB,WAAW,GAAGZ,OAAO,CACxBa,IAAI,CAACpB,eAAe,CAAC,CACrBe,cAAc,CAAChB,MAAM,CAAC;QACzBS,UAAU,GAAGA,UAAU,GAAG,KAAK,GAAGW,WAAW;;;IAIjD,OAAOX,UAAU;EACnB;EAAC,QAAAa,CAAA,G;qBAjHU9B,iBAAiB,EAAA+B,EAAA,CAAAC,iBAAA,CAAAC,EAAA,CAAAC,gBAAA;EAAA;EAAA,QAAAC,EAAA,G;;UAAjBnC,iBAAiB;IAAAoC,IAAA;EAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}