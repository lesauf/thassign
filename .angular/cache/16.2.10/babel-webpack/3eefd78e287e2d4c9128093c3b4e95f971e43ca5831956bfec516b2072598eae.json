{"ast":null,"code":"import { queueScheduler, asyncScheduler } from 'rxjs';\nimport { tap, subscribeOn, observeOn } from 'rxjs/operators';\nimport { InjectionToken, Version, isDevMode, NgZone, Optional, VERSION as VERSION$1, NgModule, Inject, PLATFORM_ID } from '@angular/core';\nimport firebase from 'firebase/app';\nfunction noop() {}\n/**\n * Schedules tasks so that they are invoked inside the Zone that is passed in the constructor.\n */\n// tslint:disable-next-line:class-name\nclass ɵZoneScheduler {\n  constructor(zone, delegate = queueScheduler) {\n    this.zone = zone;\n    this.delegate = delegate;\n  }\n  now() {\n    return this.delegate.now();\n  }\n  schedule(work, delay, state) {\n    const targetZone = this.zone;\n    // Wrap the specified work function to make sure that if nested scheduling takes place the\n    // work is executed in the correct zone\n    const workInZone = function (state) {\n      targetZone.runGuarded(() => {\n        work.apply(this, [state]);\n      });\n    };\n    // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done\n    // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that\n    // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.\n    return this.delegate.schedule(workInZone, delay, state);\n  }\n}\n// tslint:disable-next-line:class-name\nclass ɵBlockUntilFirstOperator {\n  constructor(zone) {\n    this.zone = zone;\n    this.task = null;\n  }\n  call(subscriber, source) {\n    const unscheduleTask = this.unscheduleTask.bind(this);\n    this.task = this.zone.run(() => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop));\n    return source.pipe(tap({\n      next: unscheduleTask,\n      complete: unscheduleTask,\n      error: unscheduleTask\n    })).subscribe(subscriber).add(unscheduleTask);\n  }\n  unscheduleTask() {\n    // maybe this is a race condition, invoke in a timeout\n    // hold for 10ms while I try to figure out what is going on\n    setTimeout(() => {\n      if (this.task != null && this.task.state === 'scheduled') {\n        this.task.invoke();\n        this.task = null;\n      }\n    }, 10);\n  }\n}\n// tslint:disable-next-line:class-name\nclass ɵAngularFireSchedulers {\n  constructor(ngZone) {\n    this.ngZone = ngZone;\n    this.outsideAngular = ngZone.runOutsideAngular(() => new ɵZoneScheduler(Zone.current));\n    this.insideAngular = ngZone.run(() => new ɵZoneScheduler(Zone.current, asyncScheduler));\n  }\n}\n/**\n * Operator to block the zone until the first value has been emitted or the observable\n * has completed/errored. This is used to make sure that universal waits until the first\n * value from firebase but doesn't block the zone forever since the firebase subscription\n * is still alive.\n */\nfunction ɵkeepUnstableUntilFirstFactory(schedulers) {\n  return function keepUnstableUntilFirst(obs$) {\n    obs$ = obs$.lift(new ɵBlockUntilFirstOperator(schedulers.ngZone));\n    return obs$.pipe(\n    // Run the subscribe body outside of Angular (e.g. calling Firebase SDK to add a listener to a change event)\n    subscribeOn(schedulers.outsideAngular),\n    // Run operators inside the angular zone (e.g. side effects via tap())\n    observeOn(schedulers.insideAngular)\n    // INVESTIGATE https://github.com/angular/angularfire/pull/2315\n    // share()\n    );\n  };\n}\n// DEBUG quick debugger function for inline logging that typescript doesn't complain about\n//       wrote it for debugging the ɵlazySDKProxy, commenting out for now; should consider exposing a\n//       verbose mode for AngularFire in a future release that uses something like this in multiple places\n//       usage: () => log('something') || returnValue\n// const log = (...args: any[]): false => { console.log(...args); return false }\n// The problem here are things like ngOnDestroy are missing, then triggering the service\n// rather than dig too far; I'm capturing these as I go.\nconst noopFunctions = ['ngOnDestroy'];\n// INVESTIGATE should we make the Proxy revokable and do some cleanup?\n//             right now it's fairly simple but I'm sure this will grow in complexity\nconst ɵlazySDKProxy = (klass, observable, zone, options = {}) => {\n  return new Proxy(klass, {\n    get: (_, name) => zone.runOutsideAngular(() => {\n      var _a;\n      if (klass[name]) {\n        if ((_a = options === null || options === void 0 ? void 0 : options.spy) === null || _a === void 0 ? void 0 : _a.get) {\n          options.spy.get(name, klass[name]);\n        }\n        return klass[name];\n      }\n      if (noopFunctions.indexOf(name) > -1) {\n        return () => {};\n      }\n      const promise = observable.toPromise().then(mod => {\n        const ret = mod && mod[name];\n        // TODO move to proper type guards\n        if (typeof ret === 'function') {\n          return ret.bind(mod);\n        } else if (ret && ret.then) {\n          return ret.then(res => zone.run(() => res));\n        } else {\n          return zone.run(() => ret);\n        }\n      });\n      // recurse the proxy\n      return new Proxy(() => {}, {\n        get: (_, name) => promise[name],\n        // TODO handle callbacks as transparently as I can\n        apply: (self, _, args) => promise.then(it => {\n          var _a;\n          const res = it && it(...args);\n          if ((_a = options === null || options === void 0 ? void 0 : options.spy) === null || _a === void 0 ? void 0 : _a.apply) {\n            options.spy.apply(name, args, res);\n          }\n          return res;\n        })\n      });\n    })\n  });\n};\nconst ɵapplyMixins = (derivedCtor, constructors) => {\n  constructors.forEach(baseCtor => {\n    Object.getOwnPropertyNames(baseCtor.prototype || baseCtor).forEach(name => {\n      Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype || baseCtor, name));\n    });\n  });\n};\nconst FIREBASE_OPTIONS = new InjectionToken('angularfire2.app.options');\nconst FIREBASE_APP_NAME = new InjectionToken('angularfire2.app.nameOrConfig');\n// Have to implement as we need to return a class from the provider, we should consider exporting\n// this in the firebase/app types as this is our highest risk of breaks\nclass FirebaseApp {}\nconst VERSION = new Version('6.1.5');\nfunction ɵfirebaseAppFactory(options, zone, nameOrConfig) {\n  const name = typeof nameOrConfig === 'string' && nameOrConfig || '[DEFAULT]';\n  const config = typeof nameOrConfig === 'object' && nameOrConfig || {};\n  config.name = config.name || name;\n  // Added any due to some inconsistency between @firebase/app and firebase types\n  const existingApp = firebase.apps.filter(app => app && app.name === config.name)[0];\n  // We support FirebaseConfig, initializeApp's public type only accepts string; need to cast as any\n  // Could be solved with https://github.com/firebase/firebase-js-sdk/pull/1206\n  const app = existingApp || zone.runOutsideAngular(() => firebase.initializeApp(options, config));\n  try {\n    if (JSON.stringify(options) !== JSON.stringify(app.options)) {\n      const hmr = !!module.hot;\n      log('error', `${app.name} Firebase App already initialized with different options${hmr ? ', you may need to reload as Firebase is not HMR aware.' : '.'}`);\n    }\n  } catch (e) {}\n  return app;\n}\nconst ɵlogAuthEmulatorError = () => {\n  // TODO sort this out, https://github.com/angular/angularfire/issues/2656\n  log('warn', 'You may need to import \\'firebase/auth\\' manually in your component rather than rely on AngularFireAuth\\'s dynamic import, when using the emulator suite https://github.com/angular/angularfire/issues/2656');\n};\nconst log = (level, ...args) => {\n  if (isDevMode() && typeof console !== 'undefined') {\n    console[level](...args);\n  }\n};\nconst ɵ0 = log;\nglobalThis.ɵAngularfireInstanceCache || (globalThis.ɵAngularfireInstanceCache = new Map());\nfunction ɵfetchInstance(cacheKey, moduleName, app, fn, args) {\n  const [instance, ...cachedArgs] = globalThis.ɵAngularfireInstanceCache.get(cacheKey) || [];\n  if (instance) {\n    try {\n      if (args.some((arg, i) => {\n        const cachedArg = cachedArgs[i];\n        if (arg && typeof arg === 'object') {\n          return JSON.stringify(arg) !== JSON.stringify(cachedArg);\n        } else {\n          return arg !== cachedArg;\n        }\n      })) {\n        const hmr = !!module.hot;\n        log('error', `${moduleName} was already initialized on the ${app.name} Firebase App instance with different settings.${hmr ? ' You may need to reload as Firebase is not HMR aware.' : ''}`);\n      }\n    } catch (e) {}\n    return instance;\n  } else {\n    const newInstance = fn();\n    globalThis.ɵAngularfireInstanceCache.set(cacheKey, [newInstance, ...args]);\n    return newInstance;\n  }\n}\nconst FIREBASE_APP_PROVIDER = {\n  provide: FirebaseApp,\n  useFactory: ɵfirebaseAppFactory,\n  deps: [FIREBASE_OPTIONS, NgZone, [new Optional(), FIREBASE_APP_NAME]]\n};\nclass AngularFireModule {\n  // tslint:disable-next-line:ban-types\n  constructor(platformId) {\n    firebase.registerVersion('angularfire', VERSION.full, platformId.toString());\n    firebase.registerVersion('angular', VERSION$1.full);\n  }\n  static initializeApp(options, nameOrConfig) {\n    return {\n      ngModule: AngularFireModule,\n      providers: [{\n        provide: FIREBASE_OPTIONS,\n        useValue: options\n      }, {\n        provide: FIREBASE_APP_NAME,\n        useValue: nameOrConfig\n      }]\n    };\n  }\n}\nAngularFireModule.decorators = [{\n  type: NgModule,\n  args: [{\n    providers: [FIREBASE_APP_PROVIDER]\n  }]\n}];\n/** @nocollapse */\nAngularFireModule.ctorParameters = () => [{\n  type: Object,\n  decorators: [{\n    type: Inject,\n    args: [PLATFORM_ID]\n  }]\n}];\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AngularFireModule, FIREBASE_APP_NAME, FIREBASE_OPTIONS, FirebaseApp, VERSION, ɵ0, ɵAngularFireSchedulers, ɵBlockUntilFirstOperator, ɵZoneScheduler, ɵapplyMixins, ɵfetchInstance, ɵfirebaseAppFactory, ɵkeepUnstableUntilFirstFactory, ɵlazySDKProxy, ɵlogAuthEmulatorError };","map":{"version":3,"names":["queueScheduler","asyncScheduler","tap","subscribeOn","observeOn","InjectionToken","Version","isDevMode","NgZone","Optional","VERSION","VERSION$1","NgModule","Inject","PLATFORM_ID","firebase","noop","ɵZoneScheduler","constructor","zone","delegate","now","schedule","work","delay","state","targetZone","workInZone","runGuarded","apply","ɵBlockUntilFirstOperator","task","call","subscriber","source","unscheduleTask","bind","run","Zone","current","scheduleMacroTask","pipe","next","complete","error","subscribe","add","setTimeout","invoke","ɵAngularFireSchedulers","ngZone","outsideAngular","runOutsideAngular","insideAngular","ɵkeepUnstableUntilFirstFactory","schedulers","keepUnstableUntilFirst","obs$","lift","noopFunctions","ɵlazySDKProxy","klass","observable","options","Proxy","get","_","name","_a","spy","indexOf","promise","toPromise","then","mod","ret","res","self","args","it","ɵapplyMixins","derivedCtor","constructors","forEach","baseCtor","Object","getOwnPropertyNames","prototype","defineProperty","getOwnPropertyDescriptor","FIREBASE_OPTIONS","FIREBASE_APP_NAME","FirebaseApp","ɵfirebaseAppFactory","nameOrConfig","config","existingApp","apps","filter","app","initializeApp","JSON","stringify","hmr","module","hot","log","e","ɵlogAuthEmulatorError","level","console","ɵ0","globalThis","ɵAngularfireInstanceCache","Map","ɵfetchInstance","cacheKey","moduleName","fn","instance","cachedArgs","some","arg","i","cachedArg","newInstance","set","FIREBASE_APP_PROVIDER","provide","useFactory","deps","AngularFireModule","platformId","registerVersion","full","toString","ngModule","providers","useValue","decorators","type","ctorParameters"],"sources":["C:/Users/CSEG/Desktop/thassign/node_modules/@angular/fire/fesm2015/angular-fire.js"],"sourcesContent":["import { queueScheduler, asyncScheduler } from 'rxjs';\nimport { tap, subscribeOn, observeOn } from 'rxjs/operators';\nimport { InjectionToken, Version, isDevMode, NgZone, Optional, VERSION as VERSION$1, NgModule, Inject, PLATFORM_ID } from '@angular/core';\nimport firebase from 'firebase/app';\n\nfunction noop() {\n}\n/**\n * Schedules tasks so that they are invoked inside the Zone that is passed in the constructor.\n */\n// tslint:disable-next-line:class-name\nclass ɵZoneScheduler {\n    constructor(zone, delegate = queueScheduler) {\n        this.zone = zone;\n        this.delegate = delegate;\n    }\n    now() {\n        return this.delegate.now();\n    }\n    schedule(work, delay, state) {\n        const targetZone = this.zone;\n        // Wrap the specified work function to make sure that if nested scheduling takes place the\n        // work is executed in the correct zone\n        const workInZone = function (state) {\n            targetZone.runGuarded(() => {\n                work.apply(this, [state]);\n            });\n        };\n        // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done\n        // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that\n        // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.\n        return this.delegate.schedule(workInZone, delay, state);\n    }\n}\n// tslint:disable-next-line:class-name\nclass ɵBlockUntilFirstOperator {\n    constructor(zone) {\n        this.zone = zone;\n        this.task = null;\n    }\n    call(subscriber, source) {\n        const unscheduleTask = this.unscheduleTask.bind(this);\n        this.task = this.zone.run(() => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop));\n        return source.pipe(tap({ next: unscheduleTask, complete: unscheduleTask, error: unscheduleTask })).subscribe(subscriber).add(unscheduleTask);\n    }\n    unscheduleTask() {\n        // maybe this is a race condition, invoke in a timeout\n        // hold for 10ms while I try to figure out what is going on\n        setTimeout(() => {\n            if (this.task != null && this.task.state === 'scheduled') {\n                this.task.invoke();\n                this.task = null;\n            }\n        }, 10);\n    }\n}\n// tslint:disable-next-line:class-name\nclass ɵAngularFireSchedulers {\n    constructor(ngZone) {\n        this.ngZone = ngZone;\n        this.outsideAngular = ngZone.runOutsideAngular(() => new ɵZoneScheduler(Zone.current));\n        this.insideAngular = ngZone.run(() => new ɵZoneScheduler(Zone.current, asyncScheduler));\n    }\n}\n/**\n * Operator to block the zone until the first value has been emitted or the observable\n * has completed/errored. This is used to make sure that universal waits until the first\n * value from firebase but doesn't block the zone forever since the firebase subscription\n * is still alive.\n */\nfunction ɵkeepUnstableUntilFirstFactory(schedulers) {\n    return function keepUnstableUntilFirst(obs$) {\n        obs$ = obs$.lift(new ɵBlockUntilFirstOperator(schedulers.ngZone));\n        return obs$.pipe(\n        // Run the subscribe body outside of Angular (e.g. calling Firebase SDK to add a listener to a change event)\n        subscribeOn(schedulers.outsideAngular), \n        // Run operators inside the angular zone (e.g. side effects via tap())\n        observeOn(schedulers.insideAngular)\n        // INVESTIGATE https://github.com/angular/angularfire/pull/2315\n        // share()\n        );\n    };\n}\n// DEBUG quick debugger function for inline logging that typescript doesn't complain about\n//       wrote it for debugging the ɵlazySDKProxy, commenting out for now; should consider exposing a\n//       verbose mode for AngularFire in a future release that uses something like this in multiple places\n//       usage: () => log('something') || returnValue\n// const log = (...args: any[]): false => { console.log(...args); return false }\n// The problem here are things like ngOnDestroy are missing, then triggering the service\n// rather than dig too far; I'm capturing these as I go.\nconst noopFunctions = ['ngOnDestroy'];\n// INVESTIGATE should we make the Proxy revokable and do some cleanup?\n//             right now it's fairly simple but I'm sure this will grow in complexity\nconst ɵlazySDKProxy = (klass, observable, zone, options = {}) => {\n    return new Proxy(klass, {\n        get: (_, name) => zone.runOutsideAngular(() => {\n            var _a;\n            if (klass[name]) {\n                if ((_a = options === null || options === void 0 ? void 0 : options.spy) === null || _a === void 0 ? void 0 : _a.get) {\n                    options.spy.get(name, klass[name]);\n                }\n                return klass[name];\n            }\n            if (noopFunctions.indexOf(name) > -1) {\n                return () => {\n                };\n            }\n            const promise = observable.toPromise().then(mod => {\n                const ret = mod && mod[name];\n                // TODO move to proper type guards\n                if (typeof ret === 'function') {\n                    return ret.bind(mod);\n                }\n                else if (ret && ret.then) {\n                    return ret.then((res) => zone.run(() => res));\n                }\n                else {\n                    return zone.run(() => ret);\n                }\n            });\n            // recurse the proxy\n            return new Proxy(() => { }, {\n                get: (_, name) => promise[name],\n                // TODO handle callbacks as transparently as I can\n                apply: (self, _, args) => promise.then(it => {\n                    var _a;\n                    const res = it && it(...args);\n                    if ((_a = options === null || options === void 0 ? void 0 : options.spy) === null || _a === void 0 ? void 0 : _a.apply) {\n                        options.spy.apply(name, args, res);\n                    }\n                    return res;\n                })\n            });\n        })\n    });\n};\nconst ɵapplyMixins = (derivedCtor, constructors) => {\n    constructors.forEach((baseCtor) => {\n        Object.getOwnPropertyNames(baseCtor.prototype || baseCtor).forEach((name) => {\n            Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype || baseCtor, name));\n        });\n    });\n};\n\nconst FIREBASE_OPTIONS = new InjectionToken('angularfire2.app.options');\nconst FIREBASE_APP_NAME = new InjectionToken('angularfire2.app.nameOrConfig');\n// Have to implement as we need to return a class from the provider, we should consider exporting\n// this in the firebase/app types as this is our highest risk of breaks\nclass FirebaseApp {\n}\nconst VERSION = new Version('6.1.5');\nfunction ɵfirebaseAppFactory(options, zone, nameOrConfig) {\n    const name = typeof nameOrConfig === 'string' && nameOrConfig || '[DEFAULT]';\n    const config = typeof nameOrConfig === 'object' && nameOrConfig || {};\n    config.name = config.name || name;\n    // Added any due to some inconsistency between @firebase/app and firebase types\n    const existingApp = firebase.apps.filter(app => app && app.name === config.name)[0];\n    // We support FirebaseConfig, initializeApp's public type only accepts string; need to cast as any\n    // Could be solved with https://github.com/firebase/firebase-js-sdk/pull/1206\n    const app = (existingApp || zone.runOutsideAngular(() => firebase.initializeApp(options, config)));\n    try {\n        if (JSON.stringify(options) !== JSON.stringify(app.options)) {\n            const hmr = !!module.hot;\n            log('error', `${app.name} Firebase App already initialized with different options${hmr ? ', you may need to reload as Firebase is not HMR aware.' : '.'}`);\n        }\n    }\n    catch (e) { }\n    return app;\n}\nconst ɵlogAuthEmulatorError = () => {\n    // TODO sort this out, https://github.com/angular/angularfire/issues/2656\n    log('warn', 'You may need to import \\'firebase/auth\\' manually in your component rather than rely on AngularFireAuth\\'s dynamic import, when using the emulator suite https://github.com/angular/angularfire/issues/2656');\n};\nconst log = (level, ...args) => {\n    if (isDevMode() && typeof console !== 'undefined') {\n        console[level](...args);\n    }\n};\nconst ɵ0 = log;\nglobalThis.ɵAngularfireInstanceCache || (globalThis.ɵAngularfireInstanceCache = new Map());\nfunction ɵfetchInstance(cacheKey, moduleName, app, fn, args) {\n    const [instance, ...cachedArgs] = globalThis.ɵAngularfireInstanceCache.get(cacheKey) || [];\n    if (instance) {\n        try {\n            if (args.some((arg, i) => {\n                const cachedArg = cachedArgs[i];\n                if (arg && typeof arg === 'object') {\n                    return JSON.stringify(arg) !== JSON.stringify(cachedArg);\n                }\n                else {\n                    return arg !== cachedArg;\n                }\n            })) {\n                const hmr = !!module.hot;\n                log('error', `${moduleName} was already initialized on the ${app.name} Firebase App instance with different settings.${hmr ? ' You may need to reload as Firebase is not HMR aware.' : ''}`);\n            }\n        }\n        catch (e) { }\n        return instance;\n    }\n    else {\n        const newInstance = fn();\n        globalThis.ɵAngularfireInstanceCache.set(cacheKey, [newInstance, ...args]);\n        return newInstance;\n    }\n}\nconst FIREBASE_APP_PROVIDER = {\n    provide: FirebaseApp,\n    useFactory: ɵfirebaseAppFactory,\n    deps: [\n        FIREBASE_OPTIONS,\n        NgZone,\n        [new Optional(), FIREBASE_APP_NAME]\n    ]\n};\nclass AngularFireModule {\n    // tslint:disable-next-line:ban-types\n    constructor(platformId) {\n        firebase.registerVersion('angularfire', VERSION.full, platformId.toString());\n        firebase.registerVersion('angular', VERSION$1.full);\n    }\n    static initializeApp(options, nameOrConfig) {\n        return {\n            ngModule: AngularFireModule,\n            providers: [\n                { provide: FIREBASE_OPTIONS, useValue: options },\n                { provide: FIREBASE_APP_NAME, useValue: nameOrConfig }\n            ]\n        };\n    }\n}\nAngularFireModule.decorators = [\n    { type: NgModule, args: [{\n                providers: [FIREBASE_APP_PROVIDER]\n            },] }\n];\n/** @nocollapse */\nAngularFireModule.ctorParameters = () => [\n    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }\n];\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AngularFireModule, FIREBASE_APP_NAME, FIREBASE_OPTIONS, FirebaseApp, VERSION, ɵ0, ɵAngularFireSchedulers, ɵBlockUntilFirstOperator, ɵZoneScheduler, ɵapplyMixins, ɵfetchInstance, ɵfirebaseAppFactory, ɵkeepUnstableUntilFirstFactory, ɵlazySDKProxy, ɵlogAuthEmulatorError };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}